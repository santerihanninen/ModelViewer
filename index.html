<!DOCTYPE HTML>
<html>
<head>
<title>model-viewer</title>
<meta charset="utf-8">

<script type="text/javascript" src="js/webgl-utils.js"></script>
<script type="text/javascript" src="js/webgl-debug.js"></script>
<script type="text/javascript" src="js/gl-matrix-min.js"></script>
<script type="text/javascript" src="js/twgl.min.js"></script>

<script type="text/javascript">

  var gl;
  var canvas;
  var shaderProgram;

  var vars = {}; // variables

  var vertexPositionBuffer;
  var vertexNormalBuffer;
  var vertexTextureCoordBuffer;
  var vertexIndexBuffer;

  var modelRotation = 0.0;

  // var planeVertexPositionBuffer;
  // var planeVertexNormalBuffer;

  var modelViewMatrix = mat4.create();
  var projectionMatrix = mat4.create();
  var modelViewMatrixStack = [];

  var startTime;
  var lastTime;
  var currentTime;

  function loadShaderSourceFromUrl(url) {
    var source;

    var getSourceSynch = function(url) {
      var req = new XMLHttpRequest();
      req.open("GET", url, false);
      req.send(null);
      // req.status == 0 when testing locally, otherwise 200
      //return (req.status == 200) ? req.responseText : null;
      return (req.status === 0) ? req.responseText : null;
    };

    source = getSourceSynch(url);
    return source;
  }

  function createShaderFromSource(type, source) {
    var shader = gl.createShader(type);

    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (!compiled) {
      alert(gl.getShaderInfoLog(shader));
      return null;
    }
    return shader;
  }

  function setupShaders(vertexShaderUrl, fragmentShaderUrl) {

    var vertexShaderSource = loadShaderSourceFromUrl(vertexShaderUrl);
    var fragmentShaderSource = loadShaderSourceFromUrl(fragmentShaderUrl);

    var vertexShader = createShaderFromSource(gl.VERTEX_SHADER, vertexShaderSource);
    var fragmentShader = createShaderFromSource(gl.FRAGMENT_SHADER, fragmentShaderSource);
    shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      alert("Failed to setup shaders");
    }

    gl.useProgram(shaderProgram);

    // vertex shader attributes
    shaderProgram.positionAttributeLoc = gl.getAttribLocation(shaderProgram, "aPosition");
    gl.enableVertexAttribArray(shaderProgram.positionAttributeLoc);
    shaderProgram.normalAttributeLoc = gl.getAttribLocation(shaderProgram, "aNormal");
    gl.enableVertexAttribArray(shaderProgram.normalAttributeLoc);
    shaderProgram.textureCoordinatesAttributeLoc = gl.getAttribLocation(shaderProgram, "aTextureCoordinates");
    gl.enableVertexAttribArray(shaderProgram.textureCoordinatesAttributeLoc);
    shaderProgram.colorAttributeLoc = gl.getAttribLocation(shaderProgram, "aColor");
    gl.disableVertexAttribArray(shaderProgram.colorAttributeLoc);

    // vertex shader uniforms
    shaderProgram.modelViewMatrixUniformLoc = gl.getUniformLocation(shaderProgram, "uModelViewMatrix");
    shaderProgram.projectionMatrixUniformLoc = gl.getUniformLocation(shaderProgram, "uProjectionMatrix");
    shaderProgram.normalMatrixUniformLoc = gl.getUniformLocation(shaderProgram, "uNormalMatrix");

    // fragment shader uniforms
    shaderProgram.diffuseUniformLoc = gl.getUniformLocation(shaderProgram, "uDiffuse");
    shaderProgram.specularUniformLoc = gl.getUniformLocation(shaderProgram, "uSpecular");
    shaderProgram.glossinessUniformLoc = gl.getUniformLocation(shaderProgram, "uGlossiness");
    shaderProgram.directionalLightIntensityUniformLoc = gl.getUniformLocation(shaderProgram, "uDirectionalLightIntensity");
    shaderProgram.directionalLightDirectionUniformLoc = gl.getUniformLocation(shaderProgram, "uDirectionalLightDirection");
    shaderProgram.directionalLightSpecularColorUniformLoc = gl.getUniformLocation(shaderProgram, "uDirectionalLightSpecularColor");
  }

  function loadModel(url) {
    var request = new XMLHttpRequest();
    request.open("GET", url);
    request.onreadystatechange = function () {
        if (request.readyState == 4) {
            setupBuffers(JSON.parse(request.responseText));
        }
    };
    request.send();
  }

  function setupBuffers(model) {
    vertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(model.vertexPositions), gl.STATIC_DRAW);
    vars.vertexPositionBufferItemSize = 3;
    vars.vertexPositionBufferNumberOfItems = model.vertexPositions.length / 3;

    vertexNormalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(model.vertexNormals), gl.STATIC_DRAW);
    vars.vertexNormalBufferItemSize = 3;
    vars.vertexNormalBufferNumberOfItems = model.vertexNormals.length / 3;

    vertexTextureCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexTextureCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(model.vertexTextureCoords), gl.STATIC_DRAW);
    vars.vertexTextureCoordBufferItemSize = 2;
    vars.vertexTextureCoordBufferNumberOfItems = model.vertexTextureCoords.length / 2;

    vertexIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(model.indices), gl.STATIC_DRAW);
    vars.vertexIndexBufferItemSize = 1;
    vars.vertexIndexBufferNumberOfItems = model.indices.length;

    /*
    // setup the plane
    var scale = 10.0;
    var plane = [
       1.0, -1.0,  0.0,
       1.0,  1.0,  0.0,
      -1.0,  1.0,  0.0,
      -1.0,  1.0,  0.0,
      -1.0, -1.0,  0.0,
       1.0, -1.0,  0.0,

      -1.0,  1.0,  0.0,
      -1.2,  1.4,  0.0,
      -1.4,  1.0,  0.0,

       1.0, -1.0,  0.0,
       1.4, -1.8,  0.0,
       0.6, -1.8,  0.0,

       -1.0, -1.0,  0.0,
       -0.9, -1.1,  0.0,
       -1.1, -1.1,  0.0
    ];
    for (i = 0; i < plane.length; i++) {
      plane[i] *= scale;
    }

    var planeNormals = [
      0.0,  0.0,  1.0,
      0.0,  0.0,  1.0,
      0.0,  0.0,  1.0,
      0.0,  0.0,  1.0,
      0.0,  0.0,  1.0,
      0.0,  0.0,  1.0,

      0.0,  0.0,  1.0,
      0.0,  0.0,  1.0,
      0.0,  0.0,  1.0,

      0.0,  0.0,  1.0,
      0.0,  0.0,  1.0,
      0.0,  0.0,  1.0,

      0.0,  0.0,  1.0,
      0.0,  0.0,  1.0,
      0.0,  0.0,  1.0
    ];

    planeVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(plane), gl.STATIC_DRAW);
    vars.planeVertexPositionBufferItemSize = 3;
    vars.planeVertexPositionBufferNumberOfItems = plane.length / 3;

    planeVertexNormalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexNormalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(planeNormals), gl.STATIC_DRAW);
    vars.planeVertexNormalBufferItemSize = 3;
    vars.planeVertexNormalBufferNumberOfItems = planeNormals.length / 3;
    */
  }

  function degToRad(degrees) {
    return degrees * Math.PI / 180;
  }

  function pushModelViewMatrix() {
    var copy = mat4.clone(modelViewMatrix);
    modelViewMatrixStack.push(copy);
  }

  function popModelViewMatrix() {
    if (modelViewMatrixStack.length === 0) {
      throw "Error popModelViewMatrix() - Stack was empty ";
    }
    modelViewMatrix = modelViewMatrixStack.pop();
  }

  function uploadMatrixUniformsToShader() {
    gl.uniformMatrix4fv(shaderProgram.modelViewMatrixUniformLoc, false, modelViewMatrix);

    gl.uniformMatrix4fv(shaderProgram.projectionMatrixUniformLoc, false, projectionMatrix);

    var normalMatrix = mat3.create();
    mat3.normalFromMat4(normalMatrix, modelViewMatrix);
    gl.uniformMatrix3fv(shaderProgram.normalMatrixUniformLoc, false, normalMatrix);
  }

  function draw() {

    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // FIXME shouldn't check the model constantly till its loaded
    if (vertexPositionBuffer == null ||
        vertexIndexBuffer == null ||
        vertexNormalBuffer == null ||
        vertexTextureCoordBuffer == null) {
        return;
    }
    var aspect = canvas.clientWidth / canvas.clientHeight;
    mat4.perspective(projectionMatrix, 45.0, aspect, 0.1, 100.0);

    mat4.identity(modelViewMatrix);

    var eye = [0, -20.0, 12.0];
    var center = [0.0, 0.0, 3.0];
    var up = [0.0, 0.0, 1.0];

    mat4.lookAt(modelViewMatrix, eye, center, up);

    // DIRECTIONAL LIGHT
    var d = vec3.fromValues(10.0, 3.0, 17.0);
    vec3.normalize(d, d);

    pushModelViewMatrix();

    var scale = 0.6;

    mat4.scale(modelViewMatrix,  modelViewMatrix, [scale, scale, scale]);

    mat4.translate(modelViewMatrix, modelViewMatrix, [0.0, 0.0, 7.0]);

    mat4.rotate(modelViewMatrix, modelViewMatrix, modelRotation,  [0.0, 0.0, 1.0]);
    mat4.rotate(modelViewMatrix, modelViewMatrix, 3.14 / 2,  [1.0, 0.0, 0.0]);

    gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.positionAttributeLoc,
                           vars.vertexPositionBufferItemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer);
    gl.vertexAttribPointer(shaderProgram.normalAttributeLoc,
                           vars.vertexNormalBufferItemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, vertexTextureCoordBuffer);
    gl.vertexAttribPointer(shaderProgram.textureCoordinatesAttributeLoc,
                           vars.vertexTextureCoordBufferItemSize, gl.FLOAT, false, 0, 0);

    gl.vertexAttrib4f(shaderProgram.colorAttributeLoc, 1.0, 0.0, 0.0, 1.0);

    gl.uniform4f(shaderProgram.diffuseUniformLoc, 1.0, 0.2, 0.2, 1.0);
    gl.uniform3f(shaderProgram.specularUniformLoc, 1.0, 1.0, 1.0);
    gl.uniform1f(shaderProgram.glossinessUniformLoc, 50);
    gl.uniform3f(shaderProgram.directionalLightIntensityUniformLoc, 1.0, 1.0, 1.0);
    gl.uniform3f(shaderProgram.directionalLightDirectionUniformLoc, d[0], d[1], d[2]);
    gl.uniform3f(shaderProgram.directionalLightSpecularColorUniformLoc, 0.8, 0.8, 0.8);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuffer);

    uploadMatrixUniformsToShader();

    gl.drawElements(gl.TRIANGLES, vars.vertexIndexBufferNumberOfItems, gl.UNSIGNED_SHORT, 0);

    popModelViewMatrix();
    /*
    pushModelViewMatrix();

    //mat4.translate(modelViewMatrix, modelViewMatrix, [0, 0, 0.0]);
    // plane
    gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.positionAttributeLoc,
                           vars.planeVertexPositionBufferItemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexNormalBuffer);
    gl.vertexAttribPointer(shaderProgram.normalAttributeLoc,
                           vars.planeVertexNormalBufferItemSize, gl.FLOAT, false, 0, 0);

    gl.uniform4f(shaderProgram.diffuseUniformLoc, 0.2, 1.0, 0.2, 1.0);
    gl.uniform4f(shaderProgram.specularUniformLoc, 0.2, 1.0, 0.2, 1.0);
    gl.uniform1f(shaderProgram.glossinessUniformLoc, 50);
    gl.uniform3f(shaderProgram.directionalLightIntensityUniformLoc, 1.0, 1.0, 1.0);
    gl.uniform3f(shaderProgram.directionalLightDirectionUniformLoc, -1.0, 1.0, -1.0);
    gl.uniform3f(shaderProgram.directionalLightSpecularColorUniformLoc, 0.8, 0.8, 0.8);

    uploadMatrixUniformsToShader();

    gl.drawArrays(gl.TRIANGLES, 0, vars.planeVertexPositionBufferNumberOfItems);

    popModelViewMatrix();
    */
  }

  function animate() {

    currentTime = Date.now();

    if (startTime === undefined) {
      startTime = currentTime;
    }
    if (lastTime !== 0 && lastTime !== undefined) {
        var elapsed = currentTime - lastTime;
        modelRotation += 0.0005 * elapsed;
    }
    lastTime = currentTime;
  }

  function tick() {
    requestAnimationFrame(tick);
    draw();
    animate();
  }

  function handleContextLost(event) {
    event.preventDefault();
    cancelRequestAnimationFrame(vars.requestId);
  }

  function handleContextRestored(event) {
    init();
    vars.requestId = requestAnimationFrame(draw, canvas);
  }

  function init() {
    setupShaders("shader/vs.glsl", "shader/fs.glsl");
    loadModel("models/teapot.json");
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.enable(gl.DEPTH_TEST);
  }

  function start() {
    canvas = document.getElementById("gl-canvas");
    // canvas = WebGLDebugUtils.makeLostContextSimulatingCanvas(canvas);

    // canvas.addEventListener("webglcontextlost", handleContextLost, false);
    // canvas.addEventListener("webglcontextrestored", handleContextRestored, false);

    // gl = twgl.getWebGLContext(canvas);
    gl = WebGLDebugUtils.makeDebugContext(twgl.getWebGLContext(canvas));
    init();

    // Uncomment the three lines of code below to be able to test lost context
    // window.addEventListener('mousedown', function() {
    //  canvas.loseContext();
    // });

    tick();
  }

</script>

</head>

<body onload="start();">
  <canvas id="gl-canvas" width="1200" height="800"></canvas>
</body>

</html>
